#!/bin/bash
# Refer https://github.com/rahul003/hudl/blob/master/README.md for detailed usage instructions
usage() {
  echo "Hudl - A bash utility to execute commands on a huddle of machines
Usage: 
  -h hostsfile 
     default=hosts
  -n number of hosts to read from hostsfile
  -i identityfile for ssh
  -t tmux mode
  -l log mode
  -v verbose mode
  -c copy source path
  -d copy destination path
  -s script path
  Refer https://github.com/rahul003/hudl/blob/master/README.md for detailed usage instructions"
}

error() {
  echo "Run '"hudl"' to see instructions on how to use this usage of this tool"
}

# adds tmux prefix if required
prepare_final_command() {
  # tmux_mode=$1
  # log_mode=$2
  # log_dir=$3
  command=$1
  finalcommand=""

  if [ $tmux_mode == true ]
  then
    if [ $log_mode == true ]
    then
      command="mkdir -p $log_dir && $command"
      LOG_FILE=$log_dir`date +%Y%m%d_%H%M%SZ`
      LOG_FILE+='.log'
      finalcommand+="tmux new-session -d \"$command 2>&1 | tee -a $LOG_FILE\""
    else
      finalcommand+="tmux new-session -d \"$command\""
    fi
  else
    finalcommand=$command
  fi
}

parse_arguments() {
  tmux_mode=false
  log_mode=false
  log_dir='~/hudl/tmux_logs/'
  verbose_mode=false
  hosts_file="hosts"
  dest_path=""
  local OPTIND o t h c l v d s n i
  while getopts "th:c:lvd:s:n:i:" o; do
    case "${o}" in
      t)
        tmux_mode=true
        ;;
      h)
        hosts_file=$OPTARG
        ;;
      c)
        copy_path=$OPTARG
        ;;
      d)
        dest_path=$OPTARG
        ;;
      l)
        log_mode=true
        ;;
      v)
        verbose_mode=true
        ;;
      s)
        script_path=$OPTARG
        ;;
      n)
        num_hosts=$OPTARG
        ;;
      i)
        identityfile=$OPTARG
        ;;
      \?)
        error
        return 1
        ;;
    esac
  done
  shift $(($OPTIND - 1))
  command=$@

}

hudl() {
  parse_arguments $@

  # if not running script mode or copy mode, command needs to be set
  if [ -z "$command" ] && [ -z "$script_path" ] && [ -z "$copy_path" ]
  then
    usage
    return 0
  fi

  if [ $log_mode == true ] && [ $tmux_mode == false ]
  then
    echo "-l option only used with -t. Ignoring logging request"
  fi

  if [ -n "$copy_path" ] || [ -n "$script_path" ]
  then 
    if [ -n "$script_path" ]
    then
      copy_path=$script_path
      if [ -z "$dest_path" ]
      then
        dest_path='~/hudl/scripts/'
      fi
      dest_path=${dest_path}/
    fi

    count=0
    while read -u 10 host;
    do
      host=${host%% slots*}
      if [[ -n "$num_hosts" && $count -ge $num_hosts ]]
      then
        break
      fi

      copy_command=""
      if [ -n "$dest_path" ]
      then
        copy_command+='ssh -o "StrictHostKeyChecking no" '"$host"' "mkdir -p '"$dest_path"' && ';
      fi
      copy_command+='scp -o "StrictHostKeyChecking no" -r '"$copy_path"' '"$host"':'"$dest_path"'';
      echo $copy_command
      prepare_final_command "$copy_command"
      if [ $verbose_mode == true ]
      then
        echo -e 'Copying to '$host'\n'$finalcommand
      fi

      eval $finalcommand

      if [ -n "$script_path" ]
      then
        command="bash ${dest_path}$(basename $script_path) ${command}"
      fi
      let "count+=1"
    done 10<$hosts_file
    if [ -n "$script_path" ]
    then
      unset copy_path
    fi
  fi

  if [ -n "$script_path" ] || [ -z "$copy_path" ]
  then
    
    prepare_final_command $tmux_mode $log_mode $log_dir $command

    count=0
    while read -u 10 host;
    do
      host=${host%% slots*}
      if [[ -n "$num_hosts" && $count -ge $num_hosts ]]
      then
        break
      fi
      if [ $verbose_mode == true ]
      then
        echo -e "Running on ${host}:\n${finalcommand}"
      fi
      ssh -o "StrictHostKeyChecking no" $host $finalcommand ;
      let "count+=1"
    done 10<$hosts_file;
  fi
}

hudl $@